# coding=utf-8

"""
Вычисления на нейросети.
N!B! в настоящее время поддерживаются только аксоны с длиной 2!!!

Для вычислений используется TensorFlow.

компоненты:
    * in : вектор входных значений, который представлен placeholder'ом
    * a1 : вектор первых элементов аксонов
    * a2 : вектор вторых элементов аксонов
    * w  : вектор весов (variable)
    * out: выходные данные
    * p# : разного рода промежуточные данные

Calculator работает в двух режимах:
    * режим обучения НС
    * режим вычислений на НС

В режиме обучения:
    * изначально задается необходимое количество итераций в одном батче
    * нейросеть разворачивается сразу на все итерации
    * все итерации в одном батче вычисляются как единое целое
    * результатом является массив ответов нейросети
    * требуется функция потерь, которая учитывает сразу все ответы нейросети
    * веса задаются как tf.Variable
    * начальные данные аксонов инициализируются нулями, и в дальнейшем аккумулируют в себе все предыдущие вычисления
В режиме вычислений:
    * есть возможность выполнять произвольное количество итераций
    * нейросеть не разворачивается
    * все вычисления производятся по одной итерации за раз
    * для внутренних синаптических связей (между внутренними нейронами, для которых используется a2)
      при задании нейросети используется placeholder
    * все вычисления выполняются по одной итерации за раз
    * в конце итерации извлекаются данные a2, out. Значения out накапливаются в списке,
      а a2 используется для выполнения следующей итерации

В режиме вычислений

Последовательность:
     ----- init
     * a2  <- zeros
     ----- cycle
  ,->* a1  <- zeros
  |  * p1  <- tf.dynamic_stitch([in, a2])
  |  * p2  <- tf.gather(p1)                   # адаптируем к w
  |  * p3  <- tf.multiply(p2, w)
  |  * a1  <- tf.scatter_add(a1, p3)
  |  * a2  <- a1
  |  * out <- tf.gather(a2)
  `--* loop
"""

import tensorflow as tf
import neural_network
from engine import Engine

class Calculator:

    def __init__(self, nn : neural_network.NeuralNetwork):
        self._neural_network = nn
        self.clear()

    def clear(self):
        nn = self._neural_network
        d = nn.data

        # все компоненты представлены списками, т.к. для обучени НС итерации вычислений
        # должны быть развернуты на один батч. Соответственно каждой итерации соответствует один элемент в списке.

        self._in  = []
        self._a1  = []
        self._a2  = []
        self._w   = []
        self._out = []

        self._in_shape  = [len(d.input_neurons )]
        self._a1_shape  = [len(d.neurons       )]
        self._a2_shape  = [len(d.neurons       )]
        self._w_shape   = [len(d.synapses      )]
        self._out_shape = [len(d.output_neurons)]

        self._training_data = Engine.training_data()

    def _add_iteration_for_training(self):
        #inputs =

        pass
